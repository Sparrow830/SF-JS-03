// Перепишите функцию так, чтобы она писала 'Hello, {name}' в консоль только при первых трёх вызовах, начиная с 4-го ничего не делала.
// Используйте замыкания.
// 
// Исходный код:
// 
// const sayHello = name => {
//   console.log(`Hello, ${name}`);
// }
// 
// sayHello('Andrew')
// sayHello('Andrew')
// sayHello('Andrew')
// sayHello('Andrew')
// sayHello('Andrew')
// sayHello('Andrew')
// sayHello('Andrew')


// Функцию можно объявить двумя способами - через Function Declaration (объявление функции, FD) или Function Expression (выражение функции, FE).
// FD: function funcName() {// какие-то действия};
// FE: const funcName = function() {// какие-то действия};
// Функции, объявленные через FD, можно вызвать до их объявления. FE - только после объявления.
// Здесь же применяется не просто FE, а IIFE - Immediately Invoked Function Expression (выражение функции с немедленным вызовом).
// IIFE: const funcName = function() {// какие-то действия}();
// Скобки () в конце означают, что мы вызываем функцию сразу после её объявления. Это оператор вызова.
// Как и в обычной функции, скобки () могут содержать параметры и аргументы.
// Например, "const funcName = function(какие-то параметры) {// какие-то действия}; funcName(какие-то аргументы);" (FE) -
// это то же самое что и "const funcName = function(какие-то параметры) {// какие-то действия}(какие-то аргументы); (IIFE).
// Но есть существенное отличие: если в случае с FE в переменную "funcName" записывается сама функция,
// то в случае с IIFE в переменную "funcName" записывается результат выполнения функции.
// Если запись результата функции в переменную не требуется, можно сделать функцию анонимной,
// но тогда, чтобы JS не принял слово "function" за объявление функции (FD), его надо обозначить именно как выражение - например:
// !function() {// какие-то действия}();
// ~function() {// какие-то действия}();
// +function() {// какие-то действия}();
// -function() {// какие-то действия}();
// void function() {// какие-то действия}();
// Самым распространённым способом являются скобки ():
// (function() {// какие-то действия})(); - оператор вызова вынесен за скобки выражения.
// (function() {// какие-то действия}()); - оператор вызова внутри скобок выражения.
// IIFE функция не обязана быть анонимной - (function funcName() {// какие-то действия})();
// Но при этом не надо путать имя функции и переменную, в которую записывается значение функции.
// Кстати, скобки (), в которые заключено функциональное выражение, можно использовать и с переменной:
// "const funcName = (function() {// какие-то действия})();" это то же самое что и "const funcName = function() {// какие-то действия}();"
// IIFE создаёт внутри себя область видимости, доступ к которой есть только у неё.
const sayHello = (() => {
// Инициализируем IIFE. Внутри неё стрелочная функция без аргументов - "() => {}" - поэтому скобки () здесь обязательны, но при этом пустые.
  let countCalls = 0;
  return name => {
// А вот это и есть результат выполнения IIFE, который будет записан в переменную "sayHello" - стрелочная функция с параметром "name".
// Таким образом, вызывая sayHello('Andrew'), мы передаём аргумент "Andrew" в параметр "name".
    if (countCalls >= 3) return;
// Здесь "return" указан без значения, которое нужно вернуть.
// В совокупности с циклом "if", это означает, что функция прекратит выполняться, когда перестанет удовлетворять условию.
    console.log(`Hello, ${name}`);
    ++countCalls;
// Унарный оператор "++" (инкремент), здесь используется в качестве префикса,
// поэтому добавляет 1 к своему операнду и возвращает новое значение.
// Практически то же самое, что и "countCalls = countCalls + 1".
// (Если этот же оператор использовать в качестве окончания (countCalls++), то он сперва вернёт старое значение, а потом добавит 1.)
  }
})();

sayHello('Andrew');
sayHello('Andrew');
sayHello('Andrew');
sayHello('Andrew');
sayHello('Andrew');
sayHello('Andrew');
sayHello('Andrew');


// То же самое можно выполнить по-другому:
// 
// let countCalls = 0;
// const sayHello = name => {
//   if (countCalls < 3) {
//     console.log(`Hello, ${name}`);
//     ++countCalls;
//   }
// }
// 
// sayHello('Andrew');
// sayHello('Andrew');
// sayHello('Andrew');
// sayHello('Andrew');
// sayHello('Andrew');
// sayHello('Andrew');
// sayHello('Andrew');
// 
// Мне мой вариант нравится больше, но решил оставить вариант из ответов к заданию для разбора и комментирования.

// const sayHello = (() => {
//   let countCalls = 0;
// 
//   return name => {
//     if (countCalls >= 3) return;
//     console.log(`Hello, ${name}`);
//     ++countCalls;
//   }
// })();
// 
// sayHello('Andrew')
// sayHello('Andrew')
// sayHello('Andrew')
// sayHello('Andrew')
// sayHello('Andrew')
// sayHello('Andrew')
// sayHello('Andrew')