// Напишите функцию random(min, max), которая принимает минимальное и максимальное значение и возвращает целое случайное число n,
// такое, что: min ≤ n ≤ max. Эта функция понадобится нам для следующих заданий.
// 
// Используйте Math.random(), умножение и сложение.
// 
// Исходный код0:
// 
// const random = (min, max) => {
//   return 5;
// };
// 
// alert( random(0, 1) )


// Данное задание эквивалентно заданию 4 модуля 10, только здесь мы его решаем с помощью функции.
const random = (min, max) => Math.floor(Math.random() * (max + 1 - min) + min);
// Объект Math хранит в себе различные математические константы (например, число π) и функции типа вычисления квадратного корня.
// Можно считать сборником полезных функций и значений.
// Метод .floor() объекта Math округляет переданное в него число (или, как здесь, числовой результат переданного выражения) в меньшую сторону.
// Метод .random() объекта Math возвращает случайное число в диапазоне от 0 до 1, не включая 1.
// Таким образом, имея случайное число от 0 до 0.(9) и умножая его на любое другое число, можно получить, например, 0,
// что может быть меньше минимального числа, так как произведение любого числа на 0 даёт 0.
// Отсюда (Math.random() * (любое число) + min), чтобы по итогу полученное число никогда не было меньше минимального.
// В то же время, поскольку Math.random() никогда не возвращает 1, невозможно получить максимальное число - можно лишь 0.(9) от него.
// Добавив к "max" единицу, мы решаем эту проблему, а чтобы теперь у нас никогда не получалось число больше максимального и заодно
// не получались дробные числа, округляем дроби в меньшую сторону с помощью Math.floor(Math.random() * (max + 1)).
// Соединив эти два решения, получаем: Math.floor(Math.random() * (max + 1) + min). Но здесь мы уже сталкиваемся с такой проблемой,
// что итоговое число может быть больше максимального, потому что, какое бы случайное число мы ни получили, в конце всегда прибавляется "min".
// Поэтому сперва нужно получить случайное число в диапазоне до максимального, но за вычетом минимального, а потом снова прибавить минимальное.
// Отсюда: Math.floor(Math.random() * (max + 1 - min) + min).
// Вместо Math.floor(Math.random() * (max + 1 - min) + min) можно использовать округление в большую сторону:
// Math.ceil(Math.random() * (max - min) + min). Тогда отпадает необходимость прибавлять к "max" единицу,
// но в этом случае минимальное число будет выпадать крайне редко - лишь когда Math.random() вернёт строго 0.
// Если же использовать округление по обычным правилам - Math.round(Math.random() * (max - min) + min) -
// то минимальное и максимальное числа будут выпадать с равной степенью вероятности. Непонятно, почему составители ответов так не сделали.

console.log(random(10, 20));


// const random = (min, max) => {
//   const rand = min + Math.random() * (max + 1 - min);
//   return Math.floor(rand);
// };
// 
// alert( random(0, 1) )