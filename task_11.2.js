// Создайте раскрывающийся блок (accordion).
// Сверху блок с заголовком, при нажатии на который снизу показывается блок с текстом, при повторном нажатии блок с текстом скрывается.
// 
// Исходный код:
// 
// const accordions = document.querySelectorAll('.accordion');


// Разметку HTML создали в отдельном HTML-файле (task_11.2.html), подгрузили туда данный JS-файл. Также подгрузили туда CSS (task_11.2.css).
function initAccordion(element) {
  const panel = element.querySelector('.panel');
// Создаём переменную "panel", которая примет в себя результат выполнения последующего действия.
// Метод .querySelector() определён для объекта "document" и любого HTML-элемента.
// Принимает строку с названием селектора (то есть название селектора должно быть в кавычках).
// В качестве селектора может выступать тег, класс и id. Находит первый дочерний элемент, соответствующий селектору и возвращает его.
// В данном случае это первый найденный внутри переменной "element" элемент, имеющий класс .panel.
// Можно также искать элементы, вложенные в другие элементы - например, <button>, вложенные в <div>: document.querySelector('div>button')
  const header = element.querySelector('.header');
// То же самое, что и выше, то теперь с переменной "header" и для класса .header.
  header.addEventListener('click', () => panel.classList.toggle('panel--opened'));
// Метод .addEventListener() добавляет элементу действие, которое будет выполнено после срабатывания события.
// Например, на клик мышки или нажатие клавиши. Принимает строку, содержащую название события (в данном случае - 'click', то есть щелчок мыши),
// функцию, которая будет вызвана, когда событие произойдёт (в данном случае - "() => panel.classList.toggle('panel--opened')"),
// а также необязательный параметр "options" или "capture", который описывает дополнительные свойства для срабатывания события (здесь его нет).
// Свойство .classList даёт возможность просматривать и манипулировать классами элемента. Используется вместе со множеством методов.
// В данном случае используется метод .toggle(), принимающий класс, который требуется включить или выключить.
// Если при вызове .toggle() переданный класс уже присвоен элементу, то он будет убран. Если класса не было — то добавлен.
// Метод .toggle() принимает только один класс для переключения. Опционально вторым аргументом можно передать boolean-значение:
// метод .toggle() будет работать как метод .add(), если передать "true", и как метод .remove(), если передать "false".
}

const accordions = document.querySelectorAll('.accordion');
// Создаём переменную "accordions", которая примет в себя результат выполнения последующего действия.
// Метод .querySelectorAll() определён для объекта "document" и любого HTML-элемента.
// Принимает строку с названием селектора (то есть название селектора должно быть в кавычках).
// В качестве селектора может выступать тег, класс и id. Находит все дочерние элементы, соответствующие селектору и возвращает их массив.
// В данном случае это все элементы, имеющие класс .accordion.
// Таким образом, переменная "accordions" будет массивом найденных элементов с классом .accordion.
// Можно также искать элементы, вложенные в другие элементы - например, <p>, вложенные в <div>: root.querySelectorAll('div>p')
accordions.forEach(initAccordion);
// Применяем для массива "accordions" метод .forEach().
// Но если до этого мы всегда создавали функцию-колбэк прямо в месте вызова и она могла бы выглядеть здесь, например, так:
// "accordions.forEach(element => () {какой-то код});", то в данном случае мы передаём в метод заранее созданную функцию.
// Таким образом, переменная "element" поочерёдно становится каждым из элементов массива "accordions", которые мы передаём в .forEach().
// 
// Что происходит при выполнении кода:
// 1. Объявляется функция "initAccordion(element) {}".
// 2. Создаётся переменная "accordions", которая становится массивом всех элементов с классом .accordion.
// 3. К массиву "accordions" применяется метод forEach().
// Каждый элемент массива передаётся в переменную "element" и для неё запускается объявленная выше функция "initAccordion".
// 4. Таким образом, внутри каждого элемента с классом .accordion находится первый элемент с классом .panel и первый же с классом .header.
// 5. На каждый найденный .header вешается слушатель, который при клике мыши на .header добавляет или убирает класс .panel--opened
// для каждого элемента .panel, найденного внутри того же элемента .accordion, в котором был найден .header.
// Иными словами, поскольку метод .forEach() обрабатывает каждый .accordion по отдельности,
// клик по .header из одного .accordion не будет воздействовать на .panel из другого .accordion.
// 6. Поскольку в CSS-файле для класса .panel задано правило "display: none", а для .panel--opened задано правило "display: block",
// которое идёт ниже по списку и, соответственно, имеет больший приоритет,
// при добавлении класса .panel--opened к элементу с классом .panel этот элемент будет показан,
// а при убирании класса .panel--opened элемент с классом .panel будет скрыт.


// HTML:
// 
// <div class="accordion">
//   <button class="header">Информация о погоде</button>
//   <div class="panel">Сегодня 30 градусов ниже нуля. Сегодня 30 градусов ниже нуля. Сегодня 30 градусов ниже нуля. Сегодня 30 градусов ниже нуля. Сегодня 30 градусов ниже нуля. Сегодня 30 градусов ниже нуля.Сегодня 30 градусов ниже нуля. Сегодня 30 градусов ниже нуля. Сегодня 30 градусов ниже нуля.Сегодня 30 градусов ниже нуля.</div>
// </div>

// <div class="accordion">
//   <button class="header">Lorem ipsum</button>
//   <div class="panel">Далеко-далеко за словесными горами в стране, гласных и согласных живут рыбные тексты. Ручеек она вопроса но предложения, моей ipsum путь. До взгляд первую безопасную мир парадигматическая, строчка вопрос ему переулка. Буквоград, его.</div>
// </div>
// 
// 
// CSS:
// 
// p {
//   font-size: 22px;
//   font-family: sans-serif;
//   margin: 25px 15px;
// }
// 
// body {
//   margin: 0;
//   padding: 0;
// }
// 
// img {
//   margin: 0 15px;
// }
// 
// .accordion {
//   margin: 25px 15px;
//   border-radius: 5px;
//   overflow: hidden;
// }
// 
// .header {
//   width: 100%;
//   text-align: left;
//   outline: none;
//   border: none;
//   font-weight: bold;
//   font-size: 18px;
//   cursor: pointer;
//   background: cyan;
//   padding: 5px 10px;
// }
// 
// .panel {
//   padding: 5px 10px 10px;
//   background: lightblue;
//   font-size: 14px;
// }
// 
// 
// JS:
// 
// const initAccordion = element => {
//   const panel = element.querySelector('.panel');
//   const header = element.querySelector('.header');
//   header.addEventListener('click', () => {
//     panel.classList.toggle('panel--opened');
//   });
// }
// 
// const accordions = document.querySelectorAll('.accordion');
// accordions.forEach(initAccordion);