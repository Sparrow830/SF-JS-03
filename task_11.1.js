// Создайте кнопку, которая при клике создает другую кнопку, которая, в свою очередь, создаёт другую кнопку, и т.д.
// 
// Пояснение: Используйте HTML, JS и CSS.


// Кнопку создали в отдельном HTML-файле (task_11.1.html), подгрузили туда данный JS-файл.
function createNewButton(text) {
// Создаём функцию "createNewButton" с параметром "text".
  const newButton = document.createElement('button');
// Создаём переменную "newButton", которая примет в себя результат выполнения последующего действия.
// Объект "document" включает в себя содержимое веб-страницы (всё DOM-дерево), а также обеспечивает функциональность,
// которая является глобальной для документа (например, создание новых элементов).
// Из него можно получить доступ к любому узлу (HTML-элементу).
// Метод .createElement() определён для объекта "document". Принимает строку с названием тега (то есть название тега должно быть в кавычках).
// Создаёт и возвращает новый элемент с заданным тегом. В данном случае это элемент <button>.
// Таким образом, переменная "newButton" становится элементом <button>, который создан, но не вставлен в HTML-документ.
  newButton.innerHTML = text;
// Свойство .innerHTML позволяет считать содержимое элемента в виде HTML-строки или установить новый HTML.
// В данном случае мы вставляем внутрь только что созданного элемента <button> значение переменной "text".
  newButton.type = 'button';
// Задаём атрибут "type" для только что созданной кнопки:
// "submit" - отправляет данные на сервер. Это также значение по умолчанию.
// "reset" - удаляет введённые данные из формы.
// "button" - просто кнопка. Действие для неё можно задать через скрипты.
  newButton.addEventListener('click', () => createNewButton(text));
// Метод .addEventListener() добавляет элементу действие, которое будет выполнено после срабатывания события.
// Например, на клик мышки или нажатие клавиши. Принимает строку, содержащую название события (в данном случае - 'click', то есть щелчок мыши),
// функцию, которая будет вызвана, когда событие произойдёт (в данном случае - "() => createNewButton(text)"),
// а также необязательный параметр "options" или "capture", который описывает дополнительные свойства для срабатывания события (здесь его нет).
  const container = document.querySelector('.buttons');
// Создаём переменную "container", которая примет в себя результат выполнения последующего действия.
// Метод .querySelector() определён для объекта "document" и любого HTML-элемента.
// Принимает строку с названием селектора (то есть название селектора должно быть в кавычках).
// В качестве селектора может выступать тег, класс и id. Находит первый дочерний элемент, соответствующий селектору и возвращает его.
// В данном случае это первый найденный внутри всего документа элемент, имеющий класс .buttons.
// Таким образом, в соответствии с нашим HTML-файлом, переменная "container" будет содержать в себе следующий код:
// <div class="buttons">
//   <button type="button">Клонировать!</button>
// </div>
// Можно также искать элементы, вложенные в другие элементы - например, <button>, вложенные в <div>: document.querySelector('div>button')
  container.appendChild(newButton);
// Метод .appendChild() позволяет добавить узел (в данном случае "newButton") в конец списка дочерних элементов указанного "родителя" (container).
// В том случае, если элемент уже существует в текущем родительском элементе, то он сперва удаляется, а затем вставляется заново.
// Отсюда следует, что один и тот же элемент в документе, на который ссылается метод .appendChild() при добавлении,
// не может находится в нескольких "родителях" одновременно.
// Но в данном случае с помощью "newButton" создаётся новый элемент, а не перемещается уже существующий.
}

const [button] = document.getElementsByTagName('button');
// Здесь используется деструктуризация массива.
// Создаём массив из одной или нескольких переменных, которым присваиваются соответствующие значения из правой части выражения.
// Метод .getElementsByTagName() определён для объекта "document" и любого HTML-элемента.
// Принимает строку с названием тега (то есть название тега должно быть в кавычках).
// Находит все дочерние элементы с соответствующим тегом и возвращает их массив.
// Метод .getElementsByTagName() возвращает живую коллекцию.
// Это означает, что коллекция будет автоматически обновляться, если на странице появятся подходящие элементы.
// В данном случае это все элементы <button> внутри объекта "document".
// Таким образом, каждой переменной из массива в левой части выражения будет присвоено значение в виде соответствующего ей элемента <button>.
// Например, первой переменной в массиве будет присвоен первый найденный элемент <button>, второй переменной - второй элемент и т.д.
// Но поскольку в данном случае в массиве лишь одна переменная (button), то ей будет присвоен первый элемент <button>,
// а все остальные элементы <button> будут отброшены.
button.addEventListener('click', () => createNewButton('Клонировать!'));
// Метод .addEventListener() добавляет элементу действие, которое будет выполнено после срабатывания события.
// Например, на клик мышки или нажатие клавиши. Принимает строку, содержащую название события (в данном случае - 'click', то есть щелчок мыши),
// функцию, которая будет вызвана, когда событие произойдёт (в данном случае - "() => createNewButton('Клонировать!')"),
// а также необязательный параметр "options" или "capture", который описывает дополнительные свойства для срабатывания события (здесь его нет).
// 
// Что происходит при выполнении кода:
// 1. Объявляется функция "createNewButton(text) {}".
// 2. Создаётся переменная "button", которой присваивается первый элемент <button> в HTML-документе (сколько бы элементов <button> ни было).
// 3. На эту кнопку "button" вешается слушатель, который срабатывает на клик по этой кнопке
// и запускает функцию "createNewButton(text) {}" с переданным в параметр "text" аргументом "Клонировать!" (т.е. text = 'Клонировать!').
// 4. Начинает отрабатывать функция.
// Создаётся переменная "newButton", которая становится элементом <button>, который создан, но ещё не вставлен в HTML-документ.
// 5. С помощью "newButton.innerHTML = text;" в только что созданную кнопку вставляется строка "Клонировать!"
// 6. С помощью "newButton.type = 'button';" только что созданной кнопке задаётся тип "button".
// 7. На только что созданную кнопку "newButton" также вешается слушатель,
// который срабатывает на клик по этой кнопке и запускает функцию "createNewButton(text) {}".
// То есть теперь функция запускается не только через клик по изначальной кнопке, но и по любой из созданных с помощью себя самой.
// 8. Создаётся переменная "container", которой присваивается элемент <div>, внутрь которого вложен изначальный элемент <button>.
// 9. С помощью "container.appendChild(newButton);" каждая новая кнопка добавляется внутрь <div> и размещается в конце.


// HTML:
// 
// <div class="buttons">
//   <button type="button">Клонировать!</button>
// </div>
// 
// 
// CSS:
// 
// button {
//   padding: 5px 10px;
//   margin-bottom: 5px;
// }
// 
// .buttons {
//   display: flex;
//   align-items: center;
//   justify-content: space-between;
//   flex-wrap: wrap;
// }
// 
// 
// JS:
// 
// const createNewButton = (text) => {
//   const newButton = document.createElement('button');
//   newButton.innerHTML = text;
//   newButton.type = 'button';
//   newButton.addEventListener('click', () => createNewButton(text));
// 
//   const container = document.querySelector('.buttons');
//   container.appendChild(newButton);
// };
// 
// const [button] = document.getElementsByTagName('button');
// button.addEventListener('click', () => createNewButton('Клонировать!'));